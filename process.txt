#? BACKGROUND AND FOREGROUND

C-Z ## make a process go to the background
htop & ## background process when executed - prints job ID and process ID
jobs ## print background processes and their job ID
jobs -p ## print process ID of backgroud processes

fg ## make most recent background process go back to the foreground
fg %1 ## make job ID 1 process go back to the foreground
kill %1 ## kill job ID 1 process go back to the foreground - send SIGTERM
kill -9 $(jobs -p) ## kill all background processes - send SIGKILL

#? DISPLAY PROCESSES

ps ## Static display of processes attached to the current shell
## PID: process ID
## TTY: terminal responsible for the command - tty are "real" terminal, pts are virtual terminal
## TIME: cpu time taken by the process
## CMD: command executed
ps a ## prints also processes by other users, details more commands run and adds the STAT column
## STAT: status of the process
## R is running
## S is sleeping (waiting for user input)
## D is uninterruptible sleep (waiting for hardware request)
## T is stopped
## Z is zombie (completed but parent process didn't read exit status yet, doesn't consume system resources anymore)
## I is idle state
## ADDITIONAL FLAGS: additional information in status column
## < is high priority process
## N is low priority process
## L is locket in memory
## s is session leader, first process in a session
## l is multithreaded
## + is foreground process group, you see it on the screen if you look at its terminal
ps au ## prints new colums: user, %cpu, %mem, vsz, rss and start
## USER is user responsible for the process
## %CPU is cpu usage
## %MEM is memory usage
## VSZ is virtual memory size in kb, i.e. memory + swap + shared libraries
## RSS is resident set size in kb, i.e. only ram physical memory
## START is start time of process
ps aux ## include system-level processes
ps aux | grep nginx ## filter nging processes
ps --sort=%cpu ## sort by cpu usage, ascending order
ps --sort=-%mem ## sort by memory usage, descending order
## other sorting criteria: user, pid, vsz, rss, tty, stat, start, time, cmd
ps -f ## more information
ps -u ## still more
ps -v ## memory usage
pstree ## Display tree of running processes

#? PRIORITY

ps -l ## long format, new colums: F, S, UID, PID, PPID, C, PRI, NI, ADDR, SZ, WCHAN
## F is flags: 0 is no flag, 1 means processe has superuser privileges, 4 means process is forked by parent process but new process created by it isn't started yet
## S is status, same thing as in ps a
## UID is user id of the user who owns the process - 0 is root, 1000 is first non-system user
## PID is process id
## PPID is parent process id
## C is cpu utilization
## PRI is priority: 80 is normal, 60 is highest priority, 99 is lowest
## NI is niceness, offset to the priority: 0 is normal, -20 is highest, 19 is lowest
## ADDR is memory address of the process's kernel stack (process involving the kernel)
## SZ is size of the process in memory measured in pages (a page is 4KB, so to get the memory size in kilobytes, multiply this value by 4)
## WCHA is waiting channel, the name of the kernel function in which the process is sleeping (waiting for some resource): - means running, poll_s means the process is waiting for a poll or select system call to finish, do_wait is waiting for child process to finish, do_sys means waiting for a system call to complete (opening file, executing program etc), do_sig means waiting for signal processing or handling in the kernel (stopped program for instance), do_select means process is waiting for a file descriptor to become ready for I/O operations

pidof vim ## get pid of all vim instances

pgrep <processname> ## Display process id
pgrep -l <processname> ## Display process id and name
pgrep -a <processname> ## Display process id and bin path
pgrep -u <username> ## Display processes of one user

kill <processid> ## Kill process giving its id
killall <processname> ## Kill process giving its name
killall -s <signal> <processname> ## Send signal to a process giving its name

uptime ## state of the host ## The three last digits indicate the system’s load average for the last minute, the last five minutes and the last fifteen minutes, respectively. Each of these numbers indicates how many processes were waiting either for CPU resources or for input/output operations to complete. This means that these processes were ready to run if they had received the respective resources.
top ## Dynamic display running processes
htop ## colored and fancier version
atop ## exists also

free ## parses /proc/meminfo and displays the amount of free and used memory in the system - default in kikibytes
free -b ## Bytes
free -m ## Mebibytes
free -g ## Gibibytes
free -h ## human-readable format
