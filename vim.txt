#? VI MODE

set -o vi ## switch to vim mode in bash
## change vi mode commands in .inputrc
set editing-mode vi ## set the default editing mode to vi
set keymap vi-command ## set the default keymap to vi-command mode
jj: vi-movement-mode ## bind the jj sequence to switch to vi movement mode

#? HELP

help {command} | only ## open help fullscreen
CTRL-] ## jump to a subject

#? ECHO

echo "message" ## echo a message
echomsg "message" ## echo a message that remains in the message-history
messages ## show message-history 

#? OPTIONS

## two types of options, boolean options and options with value
set number ## set boolean option
set nonumber ## unset boolean option
set numberwidth=4 ## set option with value
set number! ## toggle option
set number numberwidth=4 ## set multiple options at the same time

set number? ## check boolean option
set numberwidth? ## check option with value
set number? numberwidth? ## check multiple options at the same time

setlocal number ## set option only in current buffer

#? MAPPING

map - dd ## set binding
map <space> dd ## special characters
map <C-d> dd ## ctrl key
unmap - ## remove binding
map - <nop> ## set key to no operation

map ## create a key binding taking account of other custom bindings
noremap ## create a key binding using default bindings

map ## key binding from all modes but insert mode
nmap ## key binding from normal mode
imap ## key binding from insert mode
cmap ## key binding from command-line mode
vmap ## key binding from visual mode
omap ## key binding from operator-pending mode (an operator has been entered and vim waits for a motion)

nnoremap, inoremap, cnoremap, vnoremap, onoremap ## key binding from respective modes using default bindings
nunmap, iunmap, cunmap, vunmap, ounmap ## remove key binding from respective modes''

## leader key
let mapleader="," ## set , as leader key
let maplocalleader="," ## set , as local leader key - alternative leader key for specific file types and no conflict with global leader key

## special characters

<esc> ## escape
<space> ## space bar
<leader> ## leader key
<localleader> leader for a specific buffer
<CR> ## enter
<C-d> ## ctrl + d
<M-d> ## alt + d

## unused or useless keys
\ ## unused
| ## go to begining of line or go to specific column with 5| 
? ## reverse / so useless
M ## go to middle of the screen
"
z
K ## go to man page of current word
s
G
[
]
(
)
Y ## same as yy
R
Q
+ ## next line
- ## previous line
_ ## beginning of line
&
%
!
~
`

#? ABBREVIATIONS

## define shortcuts for bits of text
## the big difference with mappings is that the abbreviation is replaced only if followed by non-word character (space, enter, period, comma...)
abbreviate ## print list of abbreviations
i ## insert mode abbreviations
c ## command-line mode abbreviations
! ## global abbreviations (for both modes)
iabbreviate ## print list of insert mode abbreviations
cabbreviate ## print list of command-line mode abbreviations

abbreviate teh the ## set global abbreviation
iabbreviate teh the ## set insert mode abbreviation
cabbreviate teh the ## set command-line mode abbreviation

unabbreviate teh ## remove global abbreviation
iunabbreviate teh ## remove insert mode abbreviation
cunabbreviate teh ## remove command-line abbreviation

abbreviate btw by the way ## abbreviation expands to multiple words

#? AUTOCOMMANDS

## autocommands run commands when events happen
autocmd <event> <pattern> <command> ## set autocommand rule
autocmd ## print active rules
autocmd <event> ## print active rules for a specific event
autocmd <event> <pattern> ## print active rules for a specific event and a specific filter

autocmd BufWritePre * :normal gg=G ## before saving file, indent it automatically
autocmd BufWritePost *.txt :echo "File saved successfully" ## filter pattern, command works only on .txt files 

autocmd BufReadPost,BufNewFile * :normal OHere is your file ! ## multiple events can trigger the command
autocmd BufReadPost *.html,*.js :normal OHere is your html or js file ! ## multiple filter patterns

autocmd FileType python nnoremap <buffer> <localleader>c I//<esc> ## automatic comment addition only for python files
set filetype? ## print buffer's detected filetype
set filetype=python ## set buffer's filetype
autocmd filetype python ## list set filetype autocommands

## events

BufNewFile ## when is opened a buffer with a new file
BufEnter ## when entering a buffer
BufLeave ## when leaving a buffer

BufWritePre ## before saving file
BufWriteCmd ## instead of saving file
BufWritePost ## after saving file

TextChanged ## text was changed
InsertEnter ## entering insert mode
InsertLeave ## leaving insert mode

FileType ## when buffer filetype is set by vim

VimEnter ## entering vim
VimLeave ## leaving vim

#? MACROS

qj ## record a macro
q ## quit recording
@j ## run macro

## macro are saved in registers
registers ## see macros
let @j="" ## delete macro

#? WINDOWS

## vim command-line window
q: ## q: in normal mode allows editing history in vim mode

#? REPEAT

. ## repeat the previous action
; ## repeat the previous f/F/t/T action
, ## repeat the previous f/F/t/T action in reverse

#? INCREMENT

c-a ## increment by 1 next number
c-x ## decrement by 1 next number
5c-a ## increment by 5

#? CASE

gUmotion ## make uppercase
gu<motion> ## make lowercase
u ## in visual mode, make selected text lowercase
U ## in visual mode, make selected text uppercase

#? READ

read ## insert content from outsite
read file ## insert content of a file
read !command ## insert output of a command

#? AUTOCOMPLETION

c-n ## next match
c-p ## previous match
c-x c-f ## auto complete file path
c-x c-l ## auto complete line

#? FOLD

zo ## unfold under the cursor
zf ## fold under the cursor
zR ## open all folds
zM ## close all folds

#? SAVE

write ## save
quit ## quit
wq ## save and quit
q! ## quit without saving
ZZ ## save and quit
ZQ ## quit without saving

#? SWAPPING LETTERS

xp ## cut letter and paste it after next one

#? SURROUND PLUGIN

cs"' ## change surround " to '
ysiw" ## you surround inner word with "
ds" ## delete surround "

#? EASYMOTION

<leader><leader>s ## easymotion
<leader><leader>j ## to line below
<leader><leader>k ## to line above
4j ## four lines down
4k ## four lines up
4h ## four characters left
4l ## four characters right
4G ## go line 4

#? NEXT OCCURRENCE

* ## go to next identical word
# ## go to previous identical word

reg ## buffer of previously yanked or copied text

#? MARKS

## marks are persistent through files and exiting vim
## they work in visual mode and operator pending mode

## local marks
ma ## set mark of the cursor position to letter a
'a ## go to that line
`a ## go to exact cursor position

## global marks
ma ## works through multiple files
'a ## go to that line of the other file
`a ## go to exact cursor position of the other file

:## predefined special marks
'' ## go to line of last position
'" ## go to line where vim was exited
'^ ## go to line of last insert
'. ## go to line of last change

## command-line
mark a ## set a mark
marks ## see all marks
delmarks a ## delete a mark
delmarks ! ## delete all marks

#? BUFFERS

## buffers are files loaded in vim - all modifications or configurations are temporary stored in buffers before the file is saved
## buffers can be hidden, not showed on screen, but in vim memory

vim <file> ## open a buffer
vim <file1> <file2> ## open two buffers at the same time
e <file> ## open a buffer

ls ## display open buffers
buffers ## display open buffers

buffer 1 ## switch to buffer 1
bnext ## switch to next buffer
bprevious ## switch to previous buffer

bdelete 1 ## unload buffer 1
bdelete ## unload current buffer 

map <buffer> h dd ## set a mapping only in current buffer - has priority over not buffer-specific mappings

#? EX COMMANDS

## substitution

s/pattern/replacement ## replace first match of current line
4s/pattern/replacement ## replace on line 4
1,10s/pattern/replacement ## replace on lines 1 to 10
%s/pattern/replacement ## replace on all file

s/pattern/replacement/g ## replace all matches
s/pattern/replacement/c ## ask confirmation

s/\d/#/g ## works with regex - replace digits with hastags

## deletion

/pattern/d ## delete current line if matches pattern
g/pattern/d ## delete all lines matching pattern
g/pattern/s/foo/bar/g ## replace if line matches pattern

#? COMMAND-LINE MISCELLANEOUS

2 ## go line 2
2p ## go to line 2

normal iblop ## write bLOP where is the cursor
normal gocrac ## go last line, insert line, write crac
execute "/pattern" | normal dd ## chain commands

vim -c 'normal Gocrac' -c 'wq' file ## edit from outside vim
vim -c '/pattern' file ## search in file
